// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.25.1
// source: helath/wearable-data.proto

package healthAnalytics

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	WearableData_AddWearableData_FullMethodName    = "/health.WearableData/AddWearableData"
	WearableData_GetWearableData_FullMethodName    = "/health.WearableData/GetWearableData"
	WearableData_GetAllWearableData_FullMethodName = "/health.WearableData/GetAllWearableData"
	WearableData_UpdateWearableData_FullMethodName = "/health.WearableData/UpdateWearableData"
	WearableData_DeleteWearableData_FullMethodName = "/health.WearableData/DeleteWearableData"
)

// WearableDataClient is the client API for WearableData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WearableDataClient interface {
	AddWearableData(ctx context.Context, in *WearableDate, opts ...grpc.CallOption) (*WearableDataResponse, error)
	GetWearableData(ctx context.Context, in *WearableDataID, opts ...grpc.CallOption) (*WearableDataResponse, error)
	GetAllWearableData(ctx context.Context, in *WearableDataFilter, opts ...grpc.CallOption) (*AllWearableData, error)
	UpdateWearableData(ctx context.Context, in *UpdateWearableDate, opts ...grpc.CallOption) (*WearableDataResponse, error)
	DeleteWearableData(ctx context.Context, in *WearableDataID, opts ...grpc.CallOption) (*Message2, error)
}

type wearableDataClient struct {
	cc grpc.ClientConnInterface
}

func NewWearableDataClient(cc grpc.ClientConnInterface) WearableDataClient {
	return &wearableDataClient{cc}
}

func (c *wearableDataClient) AddWearableData(ctx context.Context, in *WearableDate, opts ...grpc.CallOption) (*WearableDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WearableDataResponse)
	err := c.cc.Invoke(ctx, WearableData_AddWearableData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wearableDataClient) GetWearableData(ctx context.Context, in *WearableDataID, opts ...grpc.CallOption) (*WearableDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WearableDataResponse)
	err := c.cc.Invoke(ctx, WearableData_GetWearableData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wearableDataClient) GetAllWearableData(ctx context.Context, in *WearableDataFilter, opts ...grpc.CallOption) (*AllWearableData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllWearableData)
	err := c.cc.Invoke(ctx, WearableData_GetAllWearableData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wearableDataClient) UpdateWearableData(ctx context.Context, in *UpdateWearableDate, opts ...grpc.CallOption) (*WearableDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WearableDataResponse)
	err := c.cc.Invoke(ctx, WearableData_UpdateWearableData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wearableDataClient) DeleteWearableData(ctx context.Context, in *WearableDataID, opts ...grpc.CallOption) (*Message2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message2)
	err := c.cc.Invoke(ctx, WearableData_DeleteWearableData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WearableDataServer is the server API for WearableData service.
// All implementations must embed UnimplementedWearableDataServer
// for forward compatibility
type WearableDataServer interface {
	AddWearableData(context.Context, *WearableDate) (*WearableDataResponse, error)
	GetWearableData(context.Context, *WearableDataID) (*WearableDataResponse, error)
	GetAllWearableData(context.Context, *WearableDataFilter) (*AllWearableData, error)
	UpdateWearableData(context.Context, *UpdateWearableDate) (*WearableDataResponse, error)
	DeleteWearableData(context.Context, *WearableDataID) (*Message2, error)
	mustEmbedUnimplementedWearableDataServer()
}

// UnimplementedWearableDataServer must be embedded to have forward compatible implementations.
type UnimplementedWearableDataServer struct {
}

func (UnimplementedWearableDataServer) AddWearableData(context.Context, *WearableDate) (*WearableDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWearableData not implemented")
}
func (UnimplementedWearableDataServer) GetWearableData(context.Context, *WearableDataID) (*WearableDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWearableData not implemented")
}
func (UnimplementedWearableDataServer) GetAllWearableData(context.Context, *WearableDataFilter) (*AllWearableData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllWearableData not implemented")
}
func (UnimplementedWearableDataServer) UpdateWearableData(context.Context, *UpdateWearableDate) (*WearableDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWearableData not implemented")
}
func (UnimplementedWearableDataServer) DeleteWearableData(context.Context, *WearableDataID) (*Message2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWearableData not implemented")
}
func (UnimplementedWearableDataServer) mustEmbedUnimplementedWearableDataServer() {}

// UnsafeWearableDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WearableDataServer will
// result in compilation errors.
type UnsafeWearableDataServer interface {
	mustEmbedUnimplementedWearableDataServer()
}

func RegisterWearableDataServer(s grpc.ServiceRegistrar, srv WearableDataServer) {
	s.RegisterService(&WearableData_ServiceDesc, srv)
}

func _WearableData_AddWearableData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WearableDate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WearableDataServer).AddWearableData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WearableData_AddWearableData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WearableDataServer).AddWearableData(ctx, req.(*WearableDate))
	}
	return interceptor(ctx, in, info, handler)
}

func _WearableData_GetWearableData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WearableDataID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WearableDataServer).GetWearableData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WearableData_GetWearableData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WearableDataServer).GetWearableData(ctx, req.(*WearableDataID))
	}
	return interceptor(ctx, in, info, handler)
}

func _WearableData_GetAllWearableData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WearableDataFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WearableDataServer).GetAllWearableData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WearableData_GetAllWearableData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WearableDataServer).GetAllWearableData(ctx, req.(*WearableDataFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _WearableData_UpdateWearableData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWearableDate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WearableDataServer).UpdateWearableData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WearableData_UpdateWearableData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WearableDataServer).UpdateWearableData(ctx, req.(*UpdateWearableDate))
	}
	return interceptor(ctx, in, info, handler)
}

func _WearableData_DeleteWearableData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WearableDataID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WearableDataServer).DeleteWearableData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WearableData_DeleteWearableData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WearableDataServer).DeleteWearableData(ctx, req.(*WearableDataID))
	}
	return interceptor(ctx, in, info, handler)
}

// WearableData_ServiceDesc is the grpc.ServiceDesc for WearableData service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WearableData_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "health.WearableData",
	HandlerType: (*WearableDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddWearableData",
			Handler:    _WearableData_AddWearableData_Handler,
		},
		{
			MethodName: "GetWearableData",
			Handler:    _WearableData_GetWearableData_Handler,
		},
		{
			MethodName: "GetAllWearableData",
			Handler:    _WearableData_GetAllWearableData_Handler,
		},
		{
			MethodName: "UpdateWearableData",
			Handler:    _WearableData_UpdateWearableData_Handler,
		},
		{
			MethodName: "DeleteWearableData",
			Handler:    _WearableData_DeleteWearableData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helath/wearable-data.proto",
}
